#include "redismodule.h"
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <pthread.h>
#include <stdint.h>
#include <stdio.h>
#include <time.h>
#include <inttypes.h>
#include <math.h>
#include "rmutil/util.h"
#include "rmutil/strings.h"
#include "rmutil/test_util.h"
#include "rmutil/alloc.h"
#include "libdehy.h"
#include "utils.h"
#include "millisecond_time.h"
#include "trie/triemap.h"


// /************************************
//  * 
//  *           DS handling
//  * 
//  ************************************/

// /*
//  * @return the number of uniqe ttl entries in the dehydrator
//  */
// size_t ttl_count(Dehydrator* dehy){
//     return dehy->element_nodes->cardinality;
// }

// /*
//  * Insert ttl for a new key or update an existing one
//  * @return DHY_OK on success, DHY_ERR on error
//  */
// int set_element_ttl(Dehydrator* dehy, char* element, size_t len, mstime_t ttl_ms){
//     char ttl_str[256];
    
//     ElementListNode* node = TrieMap_Find(dehy->element_nodes, element, len);

//     if (node != NULL && node != TRIEMAP_NOTFOUND && node != TM_NODE_DELETED){
//         // remove existing node
//         sprintf(ttl_str, "%llu", node->ttl_queue);
//         ElementList* list = TrieMap_Find(dehy->timeout_queues, ttl_str, strlen(ttl_str));
//         _listPull(dehy, list, node);
//         _removeNodeFromMapping(dehy, node);
//         deleteNode(node);
//     } 

//     //create new node
//     ElementListNode* new_node = NewNode(element, len, ttl_ms);
    
//     // put node in correct ttl queue
//     sprintf(ttl_str, "%llu", new_node->ttl_queue);
//     ElementList* new_list = TrieMap_Find(dehy->timeout_queues, ttl_str, strlen(ttl_str));
//     if (new_list == NULL || new_list == TRIEMAP_NOTFOUND || new_list == TM_NODE_DELETED){
//         // create new ttl queue
//         new_list = _createNewList();
//         TrieMap_Add(dehy->timeout_queues, ttl_str, strlen(ttl_str), new_list, NULL);
//     }
//     _listPush(new_list, new_node);
//     _addNodeToMapping(dehy, new_node);

//     return DHY_OK;
   
// }


// /*
//  * Get the expiration value for the given key
//  * @return datetime of expiration (in milliseconds) on success, -1 on error
//  */
// mstime_t get_element_ttl(Dehydrator* dehy, char* key){
//     ElementListNode* node = TrieMap_Find(dehy->element_nodes, key, strlen(key));

//     if (node != NULL && node != TRIEMAP_NOTFOUND && node != TM_NODE_DELETED)
//         return node->expiration;
//     return -1;
// }


// /*
//  * Remove TTL from the dehydrator for the given key
//  * @return DHY_OK
//  */
// int del_element_ttl(Dehydrator* dehy, char* key){
//     char ttl_str[256];
//     ElementListNode* node = TrieMap_Find(dehy->element_nodes, key, strlen(key));

//     if (node != NULL && node != TRIEMAP_NOTFOUND && node != TM_NODE_DELETED){
//         // remove existing node
//         sprintf(ttl_str, "%llu", node->ttl_queue);
//         ElementList* list = TrieMap_Find(dehy->timeout_queues, ttl_str, strlen(ttl_str));
//         _listPull(dehy, list, node);
//         _removeNodeFromMapping(dehy, node);
//         deleteNode(node);
//     } 

//     return DHY_OK;
// }


// ElementListNode* _get_next_node(Dehydrator* dehy){
//     TrieMapIterator * itr = TrieMap_Iterate(dehy->timeout_queues, "", 0);
//     char* queue_name;
//     tm_len_t len;
//     ElementList* list;
//     ElementListNode* retval = NULL;
//     while (TrieMapIterator_Next(itr, &queue_name, &len, &list)) {
//         if (list != NULL && list->len > 0 && list->head != NULL) {
//             if ((retval == NULL) || (list->head->expiration < retval->expiration))
//                 retval = list->head;
//         }
//     }
//     TrieMapIterator_Free(itr);
//     return retval;
// }

// /*
//  * @return the closest element expiration datetime (in milliseconds), or -1 if DS is empty
//  */
// mstime_t next_at(Dehydrator* dehy){
//     ElementListNode* next_node = _get_next_node(dehy);
//     if (next_node != NULL)
//         return next_node->expiration;
//     return -1;
// }


// /*
//  * Remove the element with the closest expiration datetime from the dehydrator and return it's key
//  * @return a pointer to a new string containng the key of the element with closest 
//  * expiration datetime or NULL if the dehydrator is empty.
//  */
// char* pop_next(Dehydrator* dehy) {
//     ElementListNode* next_node = _get_next_node(dehy);
    
//     if (next_node != NULL) {
//         char ttl_str[256];
//         sprintf(ttl_str, "%llu", next_node->ttl_queue);
//         ElementList* list = TrieMap_Find(dehy->timeout_queues, ttl_str, strlen(ttl_str));
//         _listPull(dehy, list, next_node);
//         _removeNodeFromMapping(dehy, next_node);
//         char* retval = strndup(next_node->element, next_node->element_len);
//         deleteNode(next_node);
//         return retval;
//     }
//     return NULL;
// }

// ElementList* pop_expired(Dehydrator* dehy) {
//     TrieMapIterator * itr = TrieMap_Iterate(dehy->timeout_queues, "", 0);
//     char* queue_name;
//     tm_len_t len;
//     ElementList* list;
//     ElementList* retval = _createNewList();
//     mstime_t now = current_time_ms() + DHY_LATANCY_MS;
//     while (TrieMapIterator_Next(itr, &queue_name, &len, &list)) {
//         while (list != NULL && list->len > 0 && list->head != NULL) {
//             if ((retval == NULL) || (list->head->expiration <= now))
//                 _listPush(retval, _listPop(dehy, list));
//         }
//     }
//     TrieMapIterator_Free(itr);
//     return retval;
// }



// /***************************
//  *       Queue Utilities
//  ***************************/

// //Creates a new Node and returns pointer to it.
// ElementListNode* NewNode(char* element, size_t element_len, mstime_t ttl)
// {
//     ElementListNode* newNode
//         = (ElementListNode*)MALLOC(sizeof(ElementListNode));

//     newNode->element = element;
//     newNode->element_len = element_len;
//     newNode->ttl_queue = ttl;
//     newNode->expiration = current_time_ms() + ttl;
//     newNode->next = NULL;
//     newNode->prev = NULL;
//     return newNode;
// }


// void deleteNode(ElementListNode* node)
// {
//     // free everything else related to the node
//     FREE(node);
// }


// //Creates a new Node and returns pointer to it.
// ElementList* _createNewList()
// {
//     ElementList* list
//         = (ElementList*)MALLOC(sizeof(ElementList));
//     list->head = NULL;
//     list->tail = NULL;
//     list->len = 0;
//     return list;
// }


// void deleteList(ElementList* list)
// {
//     ElementListNode* current = list->head;

//     // iterate over queue and find the element that has id = element_id
//     while(current != NULL)
//     {
//         ElementListNode* next = current->next; // save next
//         deleteNode(current);
//         current = next;  //move to next node
//     }

//     FREE(list);
// }


// // insert a Node at tail of linked list
// void _listPush(ElementList* list, ElementListNode* node)
// {
//     if (list->tail == NULL)
//     {
//         list->head = node;
//     }
//     else
//     {
//         node->prev = list->tail;
//         list->tail->next = node;
//     }
//     list->tail = node;
//     list->len = (list->len) + 1;
// }


// void _listPull(Dehydrator* dehy, ElementList* list, ElementListNode* node)
// {
//     if (list == NULL || list == TRIEMAP_NOTFOUND || list == TM_NODE_DELETED)
//         return;

//     if (list->len == 1)
//     {
//         list->head = NULL;
//         list->tail = NULL;
//         if (dehy != NULL) {
//             char ttl_str[256];
//             sprintf(ttl_str, "%llu", node->ttl_queue);
//             TrieMap_Delete(dehy->timeout_queues, ttl_str, strlen(ttl_str), deleteList);
//         }
//         return;
//     }

//     //hot circuit the node (carefull when pulling from tail or head)
//     if (node == list->head)
//     {
//         list->head = list->head->next;
//         list->head->prev = NULL;
//     }
//     else
//     {
//         node->prev->next = node->next;
//     }

//     if (node == list->tail) {
//         list->tail = node->prev;
//         list->tail->next = NULL;
//     }
//     else
//     {
//         node->next->prev = node->prev;
//     }
//     list->len = list->len - 1;
// }


// // pull and return the element at the first location
// ElementListNode* _listPop(Dehydrator* dehy, ElementList* list) {
//    if ((list == NULL) || (list->head == NULL)) { return NULL; } // if list empty

//    //save current head
//    ElementListNode* node = list->head;

//    if (list->len == 1)
//    {
//        list->tail = NULL;
//        list->head = NULL;
//        if (dehy != NULL) {
//             char ttl_str[256];
//             sprintf(ttl_str, "%llu", node->ttl_queue);
//             TrieMap_Delete(dehy->timeout_queues, ttl_str, strlen(ttl_str), deleteList);
//         }
//    }
//    else
//    {
//        // swap to new head
//        list->head = list->head->next;
//        list->head->prev = NULL;
//    }

//    list->len = list->len - 1;
//    return node;

// }


// /***************************
//  *   Dehydrator Utilities
//  ***************************/


// Dehydrator* newDehydrator(void)
// {

//     Dehydrator* dehy
//         = (Dehydrator*)MALLOC(sizeof(Dehydrator));

//     dehy->timeout_queues = NewTrieMap();
//     dehy->element_nodes = NewTrieMap();

//     return dehy;
// }

// void Dehydrator_Free(Dehydrator* dehy)
// {
//     TrieMap_Free(dehy->timeout_queues, deleteList);
//     TrieMap_Free(dehy->element_nodes, NULL);

//     FREE(dehy);
// }

// void _removeNodeFromMapping(Dehydrator* dehydrator, ElementListNode* node)
// {
//     TrieMap_Delete(dehydrator->element_nodes, node->element, node->element_len, NULL);
// }

// void _addNodeToMapping(Dehydrator* dehydrator, ElementListNode* node)
// {
//     TrieMap_Add(dehydrator->element_nodes, node->element, node->element_len, node ,NULL);
// }


char* printNode(ElementListNode* node)
{
    char* node_str = (char*)MALLOC((node->element_len+256+256)*sizeof(char));
    sprintf(node_str, "[elem=%s,ttl=%d,exp=%lld]", node->element, node->ttl_queue, node->expiration);
    return node_str;

}


char* printList(ElementList* list)
{
    char* list_str = MALLOC(32*sizeof(char));
    ElementListNode* current = list->head;
    sprintf(list_str, "(elements=%d)\n   head", list->len);
    // iterate over queue and find the element that has id = element_id
    while(current != NULL)
    {
        list_str = string_append(list_str, "->");
        char* node_str = printNode(current);
        list_str = string_append(list_str, node_str);
        RedisModule_Free(node_str);

        current = current->next;  //move to next node
    }
    list_str = string_append(list_str, "\n   tail points to: ");
    list_str = string_append(list_str, RedisModule_StringPtrLen(list->tail->element_id, NULL));
    list_str = string_append(list_str,"\n");
    return list_str;
}



char* printDehydrator(Dehydrator* dehydrator)
{
    char* dehy_str = RedisModule_Alloc(sizeof(char));
    khiter_t k;

    dehy_str = string_append(dehy_str, "\n======== timeout_queues =========");
    for (k = kh_begin(dehydrator->timeout_queues); k != kh_end(dehydrator->timeout_queues); ++k)
    {
        if (kh_exist(dehydrator->timeout_queues, k))
        {
            ElementList* list = kh_value(dehydrator->timeout_queues, k);
            dehy_str = string_append(dehy_str, "\n>>List: ");
            char qnum[50];
            sprintf(qnum,"%d ", kh_key(dehydrator->timeout_queues, k));
            dehy_str = string_append(dehy_str, qnum);

            char* list_str = printList(list);
            dehy_str = string_append(dehy_str, list_str);
            RedisModule_Free(list_str);
        }
    }
    dehy_str = string_append(dehy_str, "\n");

    dehy_str = string_append(dehy_str, "\n======== element_nodes issues =========\n");
    int found_problems = 0;
    for (k = kh_begin(dehydrator->element_nodes); k != kh_end(dehydrator->element_nodes); ++k)
    {
        if (kh_exist(dehydrator->element_nodes, k))
        {
            ElementListNode* node = kh_value(dehydrator->element_nodes, k);
            if (!RMUtil_StringEqualsC(node->element_id, kh_key(dehydrator->element_nodes, k)))
            {
                dehy_str = string_append(dehy_str, RedisModule_StringPtrLen(node->element_id, NULL));
                dehy_str = string_append(dehy_str, "is stored under id: ");
                dehy_str = string_append(dehy_str, kh_key(dehydrator->element_nodes, k));
                dehy_str = string_append(dehy_str, "\n");
                found_problems = 1;
            }
        }
    }
    if (!found_problems)
    {
        dehy_str = string_append(dehy_str, "no issues were found.\n");
    }
    dehy_str = string_append(dehy_str, "================================\n");

    return dehy_str;
}